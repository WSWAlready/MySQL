DQL：
查询一个字段
  slect 字段名 from 表名；
	select和from是关键字
	字段名和表名是标识符；

查询两个字段，或者多个字段
  select 字段名，使用逗号隔开，from 表明

查询所有字段
   第一种select a,b,c,d,e....from 表名；
   第二种select * from 表名；（效率低，可读性差）；

查询的列起别名
   select 表明，列名 as 别名 from 表名；（不会修改操作）
   as可以省略
	在所有数据库中，字符串同意使用单引号括起来，单引号是标准，双引号在oracle数据库在用不了，但是MySQL可以使用；

字段可以加减乘除运算


条件查询

   不是查询将所有数据都查出来，是查询出符合条件的
   语法格式：
   	select
	  字段1，字段2
	from
	   表名
  	where
	   条件；
   条件： = 等于   <> = 大于小于等于    between ....and....两个值之间，闭区间       >=  and <= 和between一样        is null 为空，is not null不为空
	  and 并且  or  或者    in  包含   not  not 可以取非   %匹配任意个字符
		在数据库中null不能使用 “=” 衡量，需要使用is；
		and 和 or同时出现会出现优先级的问题，and的优先级比or要高，使用的时候加括号。
		in使用的时候是where 数据名称 in（采用逗号隔开）；in使用的时候不是表示一个区间，是具体的值；
	   like称为模糊查询，支持%或下划线匹配，%匹配任意多个字符，下划线任意一个字符；
		例如找到名字里面含有“O”的，select ename from emp where ename like '%O%';%字符%是在名字之间，字符%是以字符开始的，
		%字符是以该字符结尾的，_字符%，是字符在第二位的；_ _字符是第二位为该字符的。
		如果寻找的名称里面有下划线的，需要加 \ 转义字符，‘%\_%’


排序
	select 名称 from emp order by sal;(默认是升序)；
	select 名称 from emp order by sal desc;(指定降序）
	select 名称 from emp order by sal asc;(指定升序）
 	
	如果一个变量是一致的，使用另一个变量升序：select ename ,sal from emp order by sal asc, ename asc;先使用sal排序，如果sal一致在使用ename排序
	

	语句的执行数据：from where select order by;(排序总在最后执行）；





数据处理函数（单行处理函数）
	
	一个输入对应一个输出，和单行相对的是多行处理函数（多个输入对应一个输出）；
	常见的单行处理函数：Lower  转换小写
			    upper  转换大写
			    substr 取子串（substr （被截取的字符串，起始下标（起始下标从1开始），截取长度））
				    找出员工的第一个名字是A的员工信息
					mysql> select ename from emp where ename like 'A%';
					+-------+
					| ename |
					+-------+
					| ALLEN |
					| ADAMS |
					+-------+
					2 rows in set (0.00 sec)

					mysql> select ename from emp where substr(ename,1,1) = 'A';
					+-------+
					| ename |
					+-------+
					| ALLEN |
					| ADAMS |
					+-------+
				     使员工名字首字母大写，使用concat拼接
					mysql> select concat (upper(substr(ename,1,1)),lower(substr(ename,2,length(ename))))from emp;
					+------------------------------------------------------------------------+
					| concat (upper(substr(ename,1,1)),lower(substr(ename,2,length(ename)))) |
					+------------------------------------------------------------------------+
					| Smith                                                                  |
					| Allen                                                                  |
					| Ward                                                                   |
					| Jones                                                                  |
					| Martin                                                                 |
					| Blake                                                                  |
					| Clark                                                                  |
					| Scott                                                                  |
					| King                                                                   |
					| Turner                                                                 |
					| Adams                                                                  |
					| James                                                                  |
					| Ford                                                                   |
					| Miller                                                                 |
					+------------------------------------------------------------------------+
			    length 取长度
			    		select length(ename) from emp;
			    trim   去空格
			    str_to_date  将字符串转换为日期
			    date_format  格式化日期
			    format 设置千分位
	 		    round  四舍五入
			    	select round(数字，n) //n指的使保留几位小数，如果n是负数，则是保留到多少位，例如-1，是保留到十位
			    	select ename from emp;
				select 'abc' from emp;
				select round(123.64) as result from emo;

			    rand() 生成随机数

			    ifnull 可以将null转换为一个具体值
			    	null只要参与运算，结果一定是null，为了避免这个现象，需要使用ifnull函数
				select（comm，0） from emp;就是将comm里面的null转换为0；
			    case .. when .. then .. when .. then .. else .. end;
			    当员工的工作岗位是MANAGER的时候工资上调10%，当工作岗位是SALESMAN的时候，工资上调50；
			    select empno,
				ename,
				job,
				(case job when 'MANAGER' then sal*1.1 when 'SALESMAN' then sal*1.5 else sal end) as newsal
			    from emp;

				+-------+--------+-----------+---------+
				| empno | ename  | job       | newsal  |
				+-------+--------+-----------+---------+
				|  7369 | SMITH  | CLERK     |  800.00 |
				|  7499 | ALLEN  | SALESMAN  | 2400.00 |
				|  7521 | WARD   | SALESMAN  | 1875.00 |
				|  7566 | JONES  | MANAGER   | 3272.50 |
				|  7654 | MARTIN | SALESMAN  | 1875.00 |
				|  7698 | BLAKE  | MANAGER   | 3135.00 |
				|  7782 | CLARK  | MANAGER   | 2695.00 |
				|  7788 | SCOTT  | ANALYST   | 3000.00 |
				|  7839 | KING   | PRESIDENT | 5000.00 |
				|  7844 | TURNER | SALESMAN  | 2250.00 |
				|  7876 | ADAMS  | CLERK     | 1100.00 |
				|  7900 | JAMES  | CLERK     |  950.00 |
				|  7902 | FORD   | ANALYST   | 3000.00 |
				|  7934 | MILLER | CLERK     | 1300.00 |
				+-------+--------+-----------+---------+


分组函数（多行处理函数）
	多行处理函数的特点：输入多行，输出一行；
	5个：
	    count    计数
	    sum	     求和
	    avg	     平均值
	    max      最大值
	    min      最小值
	
	注意：
	    分组函数在使用的时候需要先进行分组，然后才能用
	    如果没对数据进行分组，整张表默认为一组
	
	分组函数在使用的时候的注意事项：
		分组函数自动忽略null，不需要对null处理
		分组函数中count（*）和count（具体字段）的区别
			count（具体字段）：统计该字段下所有不为null的元素总数
			count（*）是表示统计整个行记录（只要某一行不全为null，则count++）
		分组函数不能直接使用在where子句中；
			select ename,sal from emp where sal > min(sal); × 原因就是分组函数必须先分组，where执行的时候，还没有分组。
						 		  	 														

		所有的分组函数可以组合起来一起用


分组查询*****
	什么是分组查询，先对数据进行分组，然后对每一组数据进行操作。
		select .. from .. group .. by ..
	
	将之前的关键字全部组合在一起，看一下他们的执行顺序：
		select .. from .. where .. group .. by
		以上关键字的顺序不能颠倒
		1.from
		2.where
		3.group by
		4.select
		5.order by
	找出每个工作岗位的工资和:在一条select语句中，若果有group by，后面的只能跟参加分组的字段，以及分组函数，其他一律不能跟
		select job,sum(sal) as sumsal from emp group by job;
		+-----------+---------+
		| job       | sumsal  |
		+-----------+---------+
		| ANALYST   | 6000.00 |
		| CLERK     | 4150.00 |
		| MANAGER   | 8275.00 |
		| PRESIDENT | 5000.00 |
		| SALESMAN  | 5600.00 |
		+-----------+---------+
	找出每个部门，不同工作岗位的最高薪资
		mysql> select job,deptno,max(sal) from emp group by deptno,job;
		+-----------+--------+----------+
		| job       | deptno | max(sal) |
		+-----------+--------+----------+
		| CLERK     |     10 |  1300.00 |
		| MANAGER   |     10 |  2450.00 |
		| PRESIDENT |     10 |  5000.00 |
		| ANALYST   |     20 |  3000.00 |
		| CLERK     |     20 |  1100.00 |
		| MANAGER   |     20 |  2975.00 |
		| CLERK     |     30 |   950.00 |
		| MANAGER   |     30 |  2850.00 |
		| SALESMAN  |     30 |  1600.00 |
		+-----------+--------+----------+
	使用having可以对分完组之后的数据进一步过滤，having不能单独使用，having不能和where同时使用。
	找出每个部门最高薪资，要求显示最高薪资大于三千的
		mysql> select deptno,max(sal) from emp group by deptno having max(sal) > 3000;
		+--------+----------+
		| deptno | max(sal) |
		+--------+----------+
		|     10 |  5000.00 |
		+--------+----------+

		mysql> select deptno,max(sal) from emp  where sal > 3000 group by deptno;
		+--------+----------+
		| deptno | max(sal) |
		+--------+----------+
		|     10 |  5000.00 |
		+--------+----------+

总结（单表查询）
select
..
from
..
where
..
group by
..
having
..
order by
..
	执行顺序
	1.from
	2.wher
	3.select
	4.group by
	5.having
	6.order by


连接查询
	去重，前面加distinct，distinct只能出现在字段的前方，而且如果后面跟好几个字段是联合查重
		select distinct job,deptno from emp ;
		+-----------+--------+
		| job       | deptno |
		+-----------+--------+
		| CLERK     |     20 |
		| SALESMAN  |     30 |
		| MANAGER   |     20 |
		| MANAGER   |     30 |
		| MANAGER   |     10 |
		| ANALYST   |     20 |
		| PRESIDENT |     10 |
		| CLERK     |     30 |
		| CLERK     |     10 |
		+-----------+--------+
	从一张表中单独查询，称为单独查询，emp和dept联合起来查询数据
	连接查询的分类：
		SQL92，SQL99

	根据表链接的方式分类：
		内连接：
			等值连接
			非等值连接
			自链接
		外连接：
			左外连接
			右外连接
		全连接
	当两张表没有任何限制进行连接时：
		案例：查询每个员工的所在部门名称
		mysql>  select ename,deptno from emp;
		+--------+--------+
		| ename  | deptno |
		+--------+--------+
		| SMITH  |     20 |
		| ALLEN  |     30 |
		| WARD   |     30 |
		| JONES  |     20 |
		| MARTIN |     30 |
		| BLAKE  |     30 |
		| CLARK  |     10 |
		| SCOTT  |     20 |
		| KING   |     10 |
		| TURNER |     30 |
		| ADAMS  |     20 |
		| JAMES  |     30 |
		| FORD   |     20 |
		| MILLER |     10 |
		+--------+--------+
		mysql> select * from dept;
		+--------+------------+----------+
		| DEPTNO | DNAME      | LOC      |
		+--------+------------+----------+
		|     10 | ACCOUNTING | NEW YORK |
		|     20 | RESEARCH   | DALLAS   |
		|     30 | SALES      | CHICAGO  |
		|     40 | OPERATIONS | BOSTON   |
		+--------+------------+----------+
		两张表连接没有任何条件限制：
		+--------+------------+
		| ename  | dname      |
		+--------+------------+
		| SMITH  | ACCOUNTING |
		| SMITH  | RESEARCH   |
		| SMITH  | SALES      |
		| SMITH  | OPERATIONS |
		| MILLER | ACCOUNTING |
		| MILLER | RESEARCH   |
		| MILLER | SALES      |
		| MILLER | OPERATIONS |
		+--------+------------+
		56 rows in set (0.00 sec)
		这是因为两个表中，一个ename匹配四个选项
	怎么避免笛卡儿积现象：
		连接时加条件，满足这个条件的记录被筛选出来
		select
		   ename,dname
		from 
		   emp,dept
		where
		   emp.deptno = dept.deptno;
		+--------+------------+
		| ename  | dname      |
		+--------+------------+
		| CLARK  | ACCOUNTING |
		| KING   | ACCOUNTING |
		| MILLER | ACCOUNTING |
		| SMITH  | RESEARCH   |
		| JONES  | RESEARCH   |
		| SCOTT  | RESEARCH   |
		| ADAMS  | RESEARCH   |
		| FORD   | RESEARCH   |
		| ALLEN  | SALES      |
		| WARD   | SALES      |
		| MARTIN | SALES      |
		| BLAKE  | SALES      |
		| TURNER | SALES      |
		| JAMES  | SALES      |
		+--------+------------+
		14 rows in set (0.07 sec)
		但是匹配次数并没有减少
	表起别名
	select
		e.ename,d.dname
	from 
		emp e,dept d
	where
		e.deptno = d.deptno;//SQL92语法
		+--------+------------+
		| ename  | dname      |
		+--------+------------+
		| CLARK  | ACCOUNTING |
		| KING   | ACCOUNTING |
		| MILLER | ACCOUNTING |
		| SMITH  | RESEARCH   |
		| JONES  | RESEARCH   |
		| SCOTT  | RESEARCH   |
		| ADAMS  | RESEARCH   |
		| FORD   | RESEARCH   |
		| ALLEN  | SALES      |
		| WARD   | SALES      |
		| MARTIN | SALES      |
		| BLAKE  | SALES      |
		| TURNER | SALES      |
		| JAMES  | SALES      |
		+--------+------------+
	内连接之等值连接
		查询每个员工的所在部门名称，显示员工名和部门名；
		SQL99语法：
		select
			e.ename,d.dname
		from 
			emp e
		inner (可省略)join 
			dept d
		on
			e.deptno = d.deptno;
	内连接之非等值连接
		找出每个员工的薪资等级，要求显示员工名，薪资，薪资等级
		select
			e.ename,e.sal,s.grade
		from
			emp e
		join
			salgrade s
		on 
			sal between losal and hisal;(条件不是等量关系)
			+--------+---------+-------+
			| ename  | sal     | grade |
			+--------+---------+-------+
			| SMITH  |  800.00 |     1 |
			| ALLEN  | 1600.00 |     3 |
			| WARD   | 1250.00 |     2 |
			| JONES  | 2975.00 |     4 |
			| MARTIN | 1250.00 |     2 |
			| BLAKE  | 2850.00 |     4 |
			| CLARK  | 2450.00 |     4 |
			| SCOTT  | 3000.00 |     4 |
			| KING   | 5000.00 |     5 |
			| TURNER | 1500.00 |     3 |
			| ADAMS  | 1100.00 |     1 |
			| JAMES  |  950.00 |     1 |
			| FORD   | 3000.00 |     4 |
			| MILLER | 1300.00 |     2 |
			+--------+---------+-------+
			14 rows in set (0.13 sec)
	内连接之自连接
		查询员工的上级领导，要求显示员工名和对应领导名
		select
			a.ename,b.ename
		from 
			emp a
		join 
			emp b
		on
			a.mgr = b.empno;
		将一张表看成两张表
		+--------+-------+
		| ename  | ename |
		+--------+-------+
		| SMITH  | FORD  |
		| ALLEN  | BLAKE |
		| WARD   | BLAKE |
		| JONES  | KING  |
		| MARTIN | BLAKE |
		| BLAKE  | KING  |
		| CLARK  | KING  |
		| SCOTT  | JONES |
		| TURNER | BLAKE |
		| ADAMS  | SCOTT |
		| JAMES  | BLAKE |
		| FORD   | JONES |
		| MILLER | CLARK |
		+--------+-------+
		13 rows in set (0.03 sec)
	外连接（右外连接）
		外连接有主次关系，内连接没有
		select
			e.ename,d.dname
		from 
			emp e right
		（outer可以省略）join 
			dept d
		on
			e.deptno = d.deptno ;
		right(表示将join关键字右边的这张表看成主表，主要是将这张表的数据全部查询出来)
		带right的是右连接，带left的是左连接
		+--------+------------+
		| ename  | dname      |
		+--------+------------+
		| CLARK  | ACCOUNTING |
		| KING   | ACCOUNTING |
		| MILLER | ACCOUNTING |
		| SMITH  | RESEARCH   |
		| JONES  | RESEARCH   |
		| SCOTT  | RESEARCH   |
		| ADAMS  | RESEARCH   |
		| FORD   | RESEARCH   |
		| ALLEN  | SALES      |
		| WARD   | SALES      |
		| MARTIN | SALES      |
		| BLAKE  | SALES      |
		| TURNER | SALES      |
		| JAMES  | SALES      |
		| NULL   | OPERATIONS |
		+--------+------------+
		15 rows in set (0.00 sec)
		查询每个员工的上级领导，要求显示所有员工的名字和领导名
		mysql> select ename,empno,mgr from emp;
		+--------+-------+------+
		| ename  | empno | mgr  |
		+--------+-------+------+
		| SMITH  |  7369 | 7902 |
		| ALLEN  |  7499 | 7698 |
		| WARD   |  7521 | 7698 |
		| JONES  |  7566 | 7839 |
		| MARTIN |  7654 | 7698 |
		| BLAKE  |  7698 | 7839 |
		| CLARK  |  7782 | 7839 |
		| SCOTT  |  7788 | 7566 |
		| KING   |  7839 | NULL |
		| TURNER |  7844 | 7698 |
		| ADAMS  |  7876 | 7788 |
		| JAMES  |  7900 | 7698 |
		| FORD   |  7902 | 7566 |
		| MILLER |  7934 | 7782 |
		+--------+-------+------+
		14 rows in set (0.00 sec)
		select 
			a.ename as '员工名',b.ename as '领导名'
		from 
			emp a left
		join
			emp b
		on
			a.mgr = b.empno;
		+--------+--------+
		| 员工名 | 领导名 |
		+--------+--------+
		| SMITH  | FORD   |
		| ALLEN  | BLAKE  |
		| WARD   | BLAKE  |
		| JONES  | KING   |
		| MARTIN | BLAKE  |
		| BLAKE  | KING   |
		| CLARK  | KING   |
		| SCOTT  | JONES  |
		| KING   | NULL   |
		| TURNER | BLAKE  |
		| ADAMS  | SCOTT  |
		| JAMES  | BLAKE  |
		| FORD   | JONES  |
		| MILLER | CLARK  |
		+--------+--------+
		14 rows in set (0.00 sec)
三张表，四张表的连接
	语法：
		select
			...
		from 
			a
		join
			b
		on
			a和b的连接条件
		join
			c
		on
			a和c的连接条件
		join
			d
		on
			a和d的连接条件
		一条SQL中内连接和外连接可以混合
		,e.sal,s.grade
	找出每个员工的部门名称以及薪资等级，要求显示员工名，部门名，薪资，薪资等级；
		select
			e.ename,d.dname	,e.sal,s.grade
		from 
			emp e
		join 
			dept d
		on
			e.deptno = d.deptno
		join
			salgrade s
		on 
			e.sal between s.losal and s.hisal;
		+--------+------------+---------+-------+
		| ename  | dname      | sal     | grade |
		+--------+------------+---------+-------+
		| SMITH  | RESEARCH   |  800.00 |     1 |
		| ALLEN  | SALES      | 1600.00 |     3 |
		| WARD   | SALES      | 1250.00 |     2 |
		| JONES  | RESEARCH   | 2975.00 |     4 |
		| MARTIN | SALES      | 1250.00 |     2 |
		| BLAKE  | SALES      | 2850.00 |     4 |
		| CLARK  | ACCOUNTING | 2450.00 |     4 |
		| SCOTT  | RESEARCH   | 3000.00 |     4 |
		| KING   | ACCOUNTING | 5000.00 |     5 |
		| TURNER | SALES      | 1500.00 |     3 |
		| ADAMS  | RESEARCH   | 1100.00 |     1 |
		| JAMES  | SALES      |  950.00 |     1 |
		| FORD   | RESEARCH   | 3000.00 |     4 |
		| MILLER | ACCOUNTING | 1300.00 |     2 |
		+--------+------------+---------+-------+
		14 rows in set (0.00 sec)
	找出每个员工的部门名称以及薪资等级，领导的名字，要求显示员工名，部门名，薪资，薪资等级；
		select
			e.ename,d.dname,e.sal,s.grade,l.ename as '领导名'
		from 
			emp e
		join 
			dept d
		on
			e.deptno = d.deptno
		join
			salgrade s
		on 
			e.sal between s.losal and s.hisal
		left join
			emp l
		on 
			e.mgr = l.empno；
		+--------+------------+---------+-------+--------+
		| ename  | dname      | sal     | grade | 领导名     |
		+--------+------------+---------+-------+--------+
		| SMITH  | RESEARCH   |  800.00 |     1 | FORD   |
		| ALLEN  | SALES      | 1600.00 |     3 | BLAKE  |
		| WARD   | SALES      | 1250.00 |     2 | BLAKE  |
		| JONES  | RESEARCH   | 2975.00 |     4 | KING   |
		| MARTIN | SALES      | 1250.00 |     2 | BLAKE  |
		| BLAKE  | SALES      | 2850.00 |     4 | KING   |
		| CLARK  | ACCOUNTING | 2450.00 |     4 | KING   |
		| SCOTT  | RESEARCH   | 3000.00 |     4 | JONES  |
		| KING   | ACCOUNTING | 5000.00 |     5 | NULL   |
		| TURNER | SALES      | 1500.00 |     3 | BLAKE  |
		| ADAMS  | RESEARCH   | 1100.00 |     1 | SCOTT  |
		| JAMES  | SALES      |  950.00 |     1 | BLAKE  |
		| FORD   | RESEARCH   | 3000.00 |     4 | JONES  |
		| MILLER | ACCOUNTING | 1300.00 |     2 | CLARK  |
		+--------+------------+---------+-------+--------+

子查询：
	select语句嵌套select语句，被嵌套的select语句称为子查询,先执行子查询
	
	子查询可以出现在哪里？
		select
			（select）
		from 
			（select）
		where
			（select）
	where子句中的子查询
		找出比最低工资高的员工姓名和工资
		select
			ename,sal
		from emp
		where
			sal > (select  min(sal) from emp);
	from子句中的子查询
		from的子查询可以将子查询的结果当作一张临时表；
		找出每个岗位的平均工资的薪资等级
		第一步：select job,avg(sal) from emp group by job;
		select
			s.grade,j.*
		from 
			(select job,avg(sal) as avgsal from emp group by job) j
		join 
			salgrade s
		on 
			j.avgsal between s.losal and s.hisal;
		+-------+-----------+-------------+
		| grade | job       | sal         |
		+-------+-----------+-------------+
		|     1 | CLERK     | 1037.500000 |
		|     2 | SALESMAN  | 1400.000000 |
		|     4 | ANALYST   | 3000.000000 |
		|     4 | MANAGER   | 2758.333333 |
		|     5 | PRESIDENT | 5000.000000 |
		+-------+-----------+-------------+
limit
	limit的作用：将查询结果集的一部分取出来，通常使用在分页查询，分页的作用是为了提高用户的体验
		因为一次全部查出来，用户体验差，可以翻页看
	
	limit的使用
		按照薪资降序排序，去除排名在前5名的员工
		select 
			ename,sal
		from 
			emp
		order by
			sal desc
		limit 5;
		+-------+---------+
		| ename | sal     |
		+-------+---------+
		| KING  | 5000.00 |
		| SCOTT | 3000.00 |
		| FORD  | 3000.00 |
		| JONES | 2975.00 |
		| BLAKE | 2850.00 |
		+-------+---------+
		5 rows in set (0.05 sec)(缺省用法，limit 5；这是去前5)
		完整用法：limit startIndex,length
			startIndex是起始下标，length是长度
			起始下标默认是从0 开始
		注意：limit在order by之后执行

分页
	每一页显示3条记录
	第一页：limit 0，3
	

表
	表的创建
		建表属于DDL语句包括：create drop alter
		语法格式：create table 表名（字段名1 数据类型 ，字段名2 数据类型，字段名3 数据类型）；
		表名：建议以t_ 或者tbl_开始，可读性强
		
		关于mysql的数据类型
		varchar （最长255）
			可变长度的字符串
			比较智能，节省空间，根据实际的数据长度动态分配空间
		char
			定长字符串
			不管实际的数据长度是多少，分配固定长度的空间
			存储数据，使用不恰当的时候会导致空间浪费
		int（长度11）
			数字中的整数性
		bigint
			数字中的长整形
		float
			数字中的浮点型
		double
			数字中的双精度浮点型
		clob
			字符大的对象，最多存储4G的字符串，超过255个字符的都要采用：clob
		blob
			二进制大对象，专门存储图片声音，视频等流媒体，需要使用IO流；
	
	t_movie		电影表（存储电影信息）
		编号		名字		描述			上映日期		时长			海报
		no(bigint)	name(varchar)	description(clob)	playtime(date)		time(double)		image(clob)
		10000		哪吒		。。。。。。		2019-10-11		2.5			。。。。
		10001		战狼		。。。。。。		2019-10-12		2.3			。。。。

	t_student
		学号		姓名			年龄		性别		邮箱地址
		no(int)		name(varchar(32))	age(int(3))	sex(char(1))	email(int(11))
		create table t_student
		(
			no int,
			name varchar(32),
			age int(3),
			sex char(1),
			email int(11)
		);
	修改数据类型：alter table 表名   modify 字段名 新的数据类型
	插入数据，insert(DML)
		语法格式：
			insert into 表名(字段1，字段名2，字段名3.。。) values(值1，值2，值3)；
			注意：字段名和值要一一对应，就是数量要对应，数据类型要对应
			insert into t_student(no,name,age,sex,email) values(1,'neimaer','20','m','12345678');
			没有给默认值，默认值就是NULL；
	格式化数字（format(数字,‘格式’)）
		select ename,format(sal,'$999,999') as sal from emp;
		+--------+-------+
		| ename  | sal   |
		+--------+-------+
		| SMITH  | 800   |
		| ALLEN  | 1,600 |
		| WARD   | 1,250 |
		| JONES  | 2,975 |
		| MARTIN | 1,250 |
		| BLAKE  | 2,850 |
		| CLARK  | 2,450 |
		| SCOTT  | 3,000 |
		| KING   | 5,000 |
		| TURNER | 1,500 |
		| ADAMS  | 1,100 |
		| JAMES  | 950   |
		| FORD   | 3,000 |
		| MILLER | 1,300 |
		+--------+-------+
	str_to_date：将字符串varchar类型转换为date类型
	date_format：将date类型转换为具有一定格式的varchar字符串类型
		所有的标识符全都是小写，单词和单词之间使用下划线进行衔接；
		mysql的日期格式
		%Y 年
		%m 月
		%d 日
		%h 小时
		%i 分
		%s 秒
	查询的时候有可以以某个特定的日期格式展示吗：
		date_format
		这个函数可以将日期类型转换为特定格式的字符串
		select id,name,date_format(birth,'%m/%d/%Y') as birth from t_user;
		date_format（日期类型数据，'日期格式'）
		这个函数通常使用在查询日期方面，设置展示的日期格式
	date和datetime的区别
		date是短日期，只包括年月日信息，
		datetime是长日期
	

	修改（update）
		语法格式：update 表名 set 字段名1=值1，字段名2=值2，字段名3=值3.。。。。where 条件;
		注意：没有条件限制会导致所有数据全部更新
		+------+----------+------------+---------------------+
		| id   | name     | birth      | create_time         |
		+------+----------+------------+---------------------+
		|    1 | zhangsan | 1999-10-01 | 2021-11-07 18:32:59 |
		|    1 | zhangsan | 1999-10-01 | 2021-11-07 18:35:26 |
		+------+----------+------------+---------------------+

		mysql> update t_user set id = 2,birth = '1999-09-06',name = 'lisi' where create_time = '2021-11-07 18:35:26';

		+------+----------+------------+---------------------+
		| id   | name     | birth      | create_time         |
		+------+----------+------------+---------------------+
		|    1 | zhangsan | 1999-10-01 | 2021-11-07 18:32:59 |
		|    2 | lisi     | 1999-09-06 | 2021-11-07 18:35:26 |
		+------+----------+------------+---------------------+
	insert插入多条记录
		 insert into t_user(id,name,birth,create_time) values(3,'wangwu','1998-10-01',now()),(4,'maliu','1997-04-12',now());
		+------+----------+------------+---------------------+
		| id   | name     | birth      | create_time         |
		+------+----------+------------+---------------------+
		|    1 | zhangsan | 1999-10-01 | 2021-11-07 18:32:59 |
		|    2 | lisi     | 1999-09-06 | 2021-11-07 18:35:26 |
		|    3 | wangwu   | 1998-10-01 | 2021-11-07 19:01:22 |
		|    4 | maliu    | 1997-04-12 | 2021-11-07 19:01:22 |
		+------+----------+------------+---------------------+
	快速删除
		delete from dept_bak;
		delete:删除之后空间不会释放，但是数据可以恢复；

		truncate
		删除效率高，表被一次截断，物理删除，但是不支持回滚。
	删除表的结构
		删除一个字段，删除一个字段，修改一个字段，
		对表的结构修改使用的是alter

约束
	什么是约束
		约束对应的是：constraint
	常见约束
		非空约束 ：not null
		唯一性约束：	unique
		主键约束：primary key简称PK
		外键约束：foreign key简称FK
		检查约束：check		mysql不支持，oracle支持
	
	非空约束：not null  只有列级约束，没有表级约束
		非空约束的字段不能为空
		create table t_vip(
			id int,
			name varchar(255) not null
			);
		insert into t_vip(id,name)values(1,'zhangsan');
		insert into t_vip(id,name)values(2,'lisi');
		insert into t_vip(id,name)values(3);
		批量添加：xx.sql这种文件被称为sql文件，我们执行sql脚本文件的时候，该文件的所有的sql语句全部执行，
			批量执行sql语句时，可以使用sql脚本文件
			怎么执行：source 加绝对路径
	唯一性约束：unique
		约束的字段不能重复，但可以为null
		两个字段联合起来唯一性
		drop table if exist t_vip;
		create table t_vip(
			id int,
			name varchar(255), 
			email varchar(255) ,
			unique(name,email)	//约束没有添加在列后面，这种约束被称为表级约束
			);
			name和email联合起来唯一
		insert into t_vip(id,name,email)values(1,'zhangsan',zhangsan@123.com);
		insert into t_vip(id,name,email)values(2,'zhangsan',zhangsan@sina.com);
		insert into t_vip(id,name,email)values(3,'zhangsan',zhangsan@sina.com);
		

		在mysql中，如果一个字段同时被not null和unique约束的话，该字段被设置为主键字段，但是在Oracle里不一样
	


	主键约束（primary key）
		主键字段：该字段添加了主键约束，这样的字段叫做：主键字段
		主键值：主键字段中的每一个值叫做：主键值

		主键值是每一行记录的唯一标识
		主键值是每一行的身份证号

		注意：任何一张表都应该有主键
		
		怎么添加主键
		drop table if exists t_vip;
		create table t_vip(
			id int	primary key,//列级约束
			name varchar(255),
			primary key(id)//表级约束
			)；
		一个表中的主键约束能加两个吗？不能主键只能有一个

		主键的建议使用
			int
			bigint
			char
			等类型
			不建议使用变长类型做主键
		
		主键分为：单一主键，复合主键，自然主键（主键值是自然数，和业务没关系），业务主键（主键值和业务紧密联系，例如银行卡号作为主键值）
			主键只要做到不重复就行，推荐使用自然主键
		create	table  t_vip(
			id int primary key auto_increment,//auto_increment表示自增，从1开始
			name varchar(255)
		);
	外键约束(foreign key 简称PK)
		外键约束的相关术语
			外键字段：该字段添加了外键约束
			外键值：外键字段当中的每一个值
		业务背景：
			设计数据库表，来描述“班级和学生的信息”
			第一种方案：班级和学生放在一起
				产生数据冗余，空间浪费
			
			第二种方案：创建两个表，班级表和学生表
		外键被引用的是父表，引用的是子表。删除的时候是先删除子，后删除父。创建的时候是先创父再创子

		create table t_vip(
			id int	primary key,//列级约束
			name varchar(255),
			foreign key (cno) reference t_class(classno) //使用方法
			)； 
		
		思考：子表中的外键引用的父表中的某个字段，被引用的这个字段必须是主键吗
			不一定是主键，但至少具有唯一性unique，
		思考：外键可以为NULL 吗？  可以
			















