DQL：
查询一个字段
  slect 字段名 from 表名；
	select和from是关键字
	字段名和表名是标识符；

查询两个字段，或者多个字段
  select 字段名，使用逗号隔开，from 表明

查询所有字段
   第一种select a,b,c,d,e....from 表名；
   第二种select * from 表名；（效率低，可读性差）；

查询的列起别名
   select 表明，列名 as 别名 from 表名；（不会修改操作）
   as可以省略
	在所有数据库中，字符串同意使用单引号括起来，单引号是标准，双引号在oracle数据库在用不了，但是MySQL可以使用；

字段可以加减乘除运算


条件查询

   不是查询将所有数据都查出来，是查询出符合条件的
   语法格式：
   	select
	  字段1，字段2
	from
	   表名
  	where
	   条件；
   条件： = 等于   <> = 大于小于等于    between ....and....两个值之间，闭区间       >=  and <= 和between一样        is null 为空，is not null不为空
	  and 并且  or  或者    in  包含   not  not 可以取非   %匹配任意个字符
		在数据库中null不能使用 “=” 衡量，需要使用is；
		and 和 or同时出现会出现优先级的问题，and的优先级比or要高，使用的时候加括号。
		in使用的时候是where 数据名称 in（采用逗号隔开）；in使用的时候不是表示一个区间，是具体的值；
	   like称为模糊查询，支持%或下划线匹配，%匹配任意多个字符，下划线任意一个字符；
		例如找到名字里面含有“O”的，select ename from emp where ename like '%O%';%字符%是在名字之间，字符%是以字符开始的，
		%字符是以该字符结尾的，_字符%，是字符在第二位的；_ _字符是第二位为该字符的。
		如果寻找的名称里面有下划线的，需要加 \ 转义字符，‘%\_%’


排序
	select 名称 from emp order by sal;(默认是升序)；
	select 名称 from emp order by sal desc;(指定降序）
	select 名称 from emp order by sal asc;(指定升序）
 	
	如果一个变量是一致的，使用另一个变量升序：select ename ,sal from emp order by sal asc, ename asc;先使用sal排序，如果sal一致在使用ename排序
	

	语句的执行数据：from where select order by;(排序总在最后执行）；





数据处理函数（单行处理函数）
	
	一个输入对应一个输出，和单行相对的是多行处理函数（多个输入对应一个输出）；
	常见的单行处理函数：Lower  转换小写
			    upper  转换大写
			    substr 取子串（substr （被截取的字符串，起始下标（起始下标从1开始），截取长度））
				    找出员工的第一个名字是A的员工信息
					mysql> select ename from emp where ename like 'A%';
					+-------+
					| ename |
					+-------+
					| ALLEN |
					| ADAMS |
					+-------+
					2 rows in set (0.00 sec)

					mysql> select ename from emp where substr(ename,1,1) = 'A';
					+-------+
					| ename |
					+-------+
					| ALLEN |
					| ADAMS |
					+-------+
				     使员工名字首字母大写，使用concat拼接
					mysql> select concat (upper(substr(ename,1,1)),lower(substr(ename,2,length(ename))))from emp;
					+------------------------------------------------------------------------+
					| concat (upper(substr(ename,1,1)),lower(substr(ename,2,length(ename)))) |
					+------------------------------------------------------------------------+
					| Smith                                                                  |
					| Allen                                                                  |
					| Ward                                                                   |
					| Jones                                                                  |
					| Martin                                                                 |
					| Blake                                                                  |
					| Clark                                                                  |
					| Scott                                                                  |
					| King                                                                   |
					| Turner                                                                 |
					| Adams                                                                  |
					| James                                                                  |
					| Ford                                                                   |
					| Miller                                                                 |
					+------------------------------------------------------------------------+
			    length 取长度
			    		select length(ename) from emp;
			    trim   去空格
			    str_to_date  将字符串转换为日期
			    date_format  格式化日期
			    format 设置千分位
	 		    round  四舍五入
			    	select round(数字，n) //n指的使保留几位小数，如果n是负数，则是保留到多少位，例如-1，是保留到十位
			    	select ename from emp;
				select 'abc' from emp;
				select round(123.64) as result from emo;

			    rand() 生成随机数

			    ifnull 可以将null转换为一个具体值
			    	null只要参与运算，结果一定是null，为了避免这个现象，需要使用ifnull函数
				select（comm，0） from emp;就是将comm里面的null转换为0；
			    case .. when .. then .. when .. then .. else .. end;
			    当员工的工作岗位是MANAGER的时候工资上调10%，当工作岗位是SALESMAN的时候，工资上调50；
			    select empno,
				ename,
				job,
				(case job when 'MANAGER' then sal*1.1 when 'SALESMAN' then sal*1.5 else sal end) as newsal
			    from emp;

				+-------+--------+-----------+---------+
				| empno | ename  | job       | newsal  |
				+-------+--------+-----------+---------+
				|  7369 | SMITH  | CLERK     |  800.00 |
				|  7499 | ALLEN  | SALESMAN  | 2400.00 |
				|  7521 | WARD   | SALESMAN  | 1875.00 |
				|  7566 | JONES  | MANAGER   | 3272.50 |
				|  7654 | MARTIN | SALESMAN  | 1875.00 |
				|  7698 | BLAKE  | MANAGER   | 3135.00 |
				|  7782 | CLARK  | MANAGER   | 2695.00 |
				|  7788 | SCOTT  | ANALYST   | 3000.00 |
				|  7839 | KING   | PRESIDENT | 5000.00 |
				|  7844 | TURNER | SALESMAN  | 2250.00 |
				|  7876 | ADAMS  | CLERK     | 1100.00 |
				|  7900 | JAMES  | CLERK     |  950.00 |
				|  7902 | FORD   | ANALYST   | 3000.00 |
				|  7934 | MILLER | CLERK     | 1300.00 |
				+-------+--------+-----------+---------+


分组函数（多行处理函数）
	多行处理函数的特点：输入多行，输出一行；
	5个：
	    count    计数
	    sum	     求和
	    avg	     平均值
	    max      最大值
	    min      最小值
	
	注意：
	    分组函数在使用的时候需要先进行分组，然后才能用
	    如果没对数据进行分组，整张表默认为一组
	
	分组函数在使用的时候的注意事项：
		分组函数自动忽略null，不需要对null处理
		分组函数中count（*）和count（具体字段）的区别
			count（具体字段）：统计该字段下所有不为null的元素总数
			count（*）是表示统计整个行记录（只要某一行不全为null，则count++）
		分组函数不能直接使用在where子句中；
			select ename,sal from emp where sal > min(sal); × 原因就是分组函数必须先分组，where执行的时候，还没有分组。
						 		  	 														

		所有的分组函数可以组合起来一起用


分组查询*****
	什么是分组查询，先对数据进行分组，然后对每一组数据进行操作。
		select .. from .. group .. by ..
	
	将之前的关键字全部组合在一起，看一下他们的执行顺序：
		select .. from .. where .. group .. by
		以上关键字的顺序不能颠倒
		1.from
		2.where
		3.group by
		4.select
		5.order by
	找出每个工作岗位的工资和:在一条select语句中，若果有group by，后面的只能跟参加分组的字段，以及分组函数，其他一律不能跟
		select job,sum(sal) as sumsal from emp group by job;
		+-----------+---------+
		| job       | sumsal  |
		+-----------+---------+
		| ANALYST   | 6000.00 |
		| CLERK     | 4150.00 |
		| MANAGER   | 8275.00 |
		| PRESIDENT | 5000.00 |
		| SALESMAN  | 5600.00 |
		+-----------+---------+
	找出每个部门，不同工作岗位的最高薪资
		mysql> select job,deptno,max(sal) from emp group by deptno,job;
		+-----------+--------+----------+
		| job       | deptno | max(sal) |
		+-----------+--------+----------+
		| CLERK     |     10 |  1300.00 |
		| MANAGER   |     10 |  2450.00 |
		| PRESIDENT |     10 |  5000.00 |
		| ANALYST   |     20 |  3000.00 |
		| CLERK     |     20 |  1100.00 |
		| MANAGER   |     20 |  2975.00 |
		| CLERK     |     30 |   950.00 |
		| MANAGER   |     30 |  2850.00 |
		| SALESMAN  |     30 |  1600.00 |
		+-----------+--------+----------+
	使用having可以对分完组之后的数据进一步过滤，having不能单独使用，having不能和where同时使用。
	找出每个部门最高薪资，要求显示最高薪资大于三千的
		mysql> select deptno,max(sal) from emp group by deptno having max(sal) > 3000;
		+--------+----------+
		| deptno | max(sal) |
		+--------+----------+
		|     10 |  5000.00 |
		+--------+----------+

		mysql> select deptno,max(sal) from emp  where sal > 3000 group by deptno;
		+--------+----------+
		| deptno | max(sal) |
		+--------+----------+
		|     10 |  5000.00 |
		+--------+----------+

总结（单表查询）
select
..
from
..
where
..
group by
..
having
..
order by
..
	执行顺序
	1.from
	2.wher
	3.select
	4.group by
	5.having
	6.order by


连接查询
	去重，前面加distinct，distinct只能出现在字段的前方，而且如果后面跟好几个字段是联合查重
		select distinct job,deptno from emp ;
		+-----------+--------+
		| job       | deptno |
		+-----------+--------+
		| CLERK     |     20 |
		| SALESMAN  |     30 |
		| MANAGER   |     20 |
		| MANAGER   |     30 |
		| MANAGER   |     10 |
		| ANALYST   |     20 |
		| PRESIDENT |     10 |
		| CLERK     |     30 |
		| CLERK     |     10 |
		+-----------+--------+
	从一张表中单独查询，称为单独查询，emp和dept联合起来查询数据
	连接查询的分类：
		SQL92，SQL99

	根据表链接的方式分类：
		内连接：
			等值连接
			非等值连接
			自链接
		外连接：
			左外连接
			右外连接
		全连接
	当两张表没有任何限制进行连接时：
		案例：查询每个员工的所在部门名称
		mysql>  select ename,deptno from emp;
		+--------+--------+
		| ename  | deptno |
		+--------+--------+
		| SMITH  |     20 |
		| ALLEN  |     30 |
		| WARD   |     30 |
		| JONES  |     20 |
		| MARTIN |     30 |
		| BLAKE  |     30 |
		| CLARK  |     10 |
		| SCOTT  |     20 |
		| KING   |     10 |
		| TURNER |     30 |
		| ADAMS  |     20 |
		| JAMES  |     30 |
		| FORD   |     20 |
		| MILLER |     10 |
		+--------+--------+
		mysql> select * from dept;
		+--------+------------+----------+
		| DEPTNO | DNAME      | LOC      |
		+--------+------------+----------+
		|     10 | ACCOUNTING | NEW YORK |
		|     20 | RESEARCH   | DALLAS   |
		|     30 | SALES      | CHICAGO  |
		|     40 | OPERATIONS | BOSTON   |
		+--------+------------+----------+
		两张表连接没有任何条件限制：
		+--------+------------+
		| ename  | dname      |
		+--------+------------+
		| SMITH  | ACCOUNTING |
		| SMITH  | RESEARCH   |
		| SMITH  | SALES      |
		| SMITH  | OPERATIONS |
		| MILLER | ACCOUNTING |
		| MILLER | RESEARCH   |
		| MILLER | SALES      |
		| MILLER | OPERATIONS |
		+--------+------------+
		56 rows in set (0.00 sec)
		这是因为两个表中，一个ename匹配四个选项
	怎么避免笛卡儿积现象：
		连接时加条件，满足这个条件的记录被筛选出来
		select
		   ename,dname
		from 
		   emp,dept
		where
		   emp.deptno = dept.deptno;
		+--------+------------+
		| ename  | dname      |
		+--------+------------+
		| CLARK  | ACCOUNTING |
		| KING   | ACCOUNTING |
		| MILLER | ACCOUNTING |
		| SMITH  | RESEARCH   |
		| JONES  | RESEARCH   |
		| SCOTT  | RESEARCH   |
		| ADAMS  | RESEARCH   |
		| FORD   | RESEARCH   |
		| ALLEN  | SALES      |
		| WARD   | SALES      |
		| MARTIN | SALES      |
		| BLAKE  | SALES      |
		| TURNER | SALES      |
		| JAMES  | SALES      |
		+--------+------------+
		14 rows in set (0.07 sec)
		但是匹配次数并没有减少
	表起别名
	select
		e.ename,d.dname
	from 
		emp e,dept d
	where
		e.deptno = d.deptno;//SQL92语法
		+--------+------------+
		| ename  | dname      |
		+--------+------------+
		| CLARK  | ACCOUNTING |
		| KING   | ACCOUNTING |
		| MILLER | ACCOUNTING |
		| SMITH  | RESEARCH   |
		| JONES  | RESEARCH   |
		| SCOTT  | RESEARCH   |
		| ADAMS  | RESEARCH   |
		| FORD   | RESEARCH   |
		| ALLEN  | SALES      |
		| WARD   | SALES      |
		| MARTIN | SALES      |
		| BLAKE  | SALES      |
		| TURNER | SALES      |
		| JAMES  | SALES      |
		+--------+------------+
	内连接之等值连接
		查询每个员工的所在部门名称，显示员工名和部门名；
		SQL99语法：
		select
			e.ename,d.dname
		from 
			emp e
		inner (可省略)join 
			dept d
		on
			e.deptno = d.deptno;
	内连接之非等值连接
		找出每个员工的薪资等级，要求显示员工名，薪资，薪资等级
		select
			e.ename,e.sal,s.grade
		from
			emp e
		join
			salgrade s
		on 
			sal between losal and hisal;(条件不是等量关系)
			+--------+---------+-------+
			| ename  | sal     | grade |
			+--------+---------+-------+
			| SMITH  |  800.00 |     1 |
			| ALLEN  | 1600.00 |     3 |
			| WARD   | 1250.00 |     2 |
			| JONES  | 2975.00 |     4 |
			| MARTIN | 1250.00 |     2 |
			| BLAKE  | 2850.00 |     4 |
			| CLARK  | 2450.00 |     4 |
			| SCOTT  | 3000.00 |     4 |
			| KING   | 5000.00 |     5 |
			| TURNER | 1500.00 |     3 |
			| ADAMS  | 1100.00 |     1 |
			| JAMES  |  950.00 |     1 |
			| FORD   | 3000.00 |     4 |
			| MILLER | 1300.00 |     2 |
			+--------+---------+-------+
			14 rows in set (0.13 sec)
	内连接之自连接
		查询员工的上级领导，要求显示员工名和对应领导名
		select
			a.ename,b.ename
		from 
			emp a
		join 
			emp b
		on
			a.mgr = b.empno;
		将一张表看成两张表
		+--------+-------+
		| ename  | ename |
		+--------+-------+
		| SMITH  | FORD  |
		| ALLEN  | BLAKE |
		| WARD   | BLAKE |
		| JONES  | KING  |
		| MARTIN | BLAKE |
		| BLAKE  | KING  |
		| CLARK  | KING  |
		| SCOTT  | JONES |
		| TURNER | BLAKE |
		| ADAMS  | SCOTT |
		| JAMES  | BLAKE |
		| FORD   | JONES |
		| MILLER | CLARK |
		+--------+-------+
		13 rows in set (0.03 sec)
		
		


















